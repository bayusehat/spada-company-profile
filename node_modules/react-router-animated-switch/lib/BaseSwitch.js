"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var PropTypes = require("prop-types");
var warning = require("warning");
var invariant = require("invariant");
var react_router_1 = require("react-router");
/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch = function (_React$Component) {
    _inherits(Switch, _React$Component);

    function Switch() {
        _classCallCheck(this, Switch);

        return _possibleConstructorReturn(this, (Switch.__proto__ || Object.getPrototypeOf(Switch)).apply(this, arguments));
    }

    _createClass(Switch, [{
        key: "componentWillMount",
        value: function componentWillMount() {
            invariant(this.context.router, 'You should not use <Switch> outside a <Router>');
        }
    }, {
        key: "componentWillReceiveProps",
        value: function componentWillReceiveProps(nextProps) {
            warning(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');
            warning(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');
        }
    }, {
        key: "render",
        value: function render() {
            var route = this.context.router.route;
            var _props = this.props,
                children = _props.children,
                render = _props.render;

            var location = this.props.location || route.location;
            var match = null,
                child = void 0,
                index = -1;
            React.Children.forEach(children, function (element, i) {
                if (match == null && React.isValidElement(element)) {
                    var _element$props = element.props,
                        pathProp = _element$props.path,
                        exact = _element$props.exact,
                        strict = _element$props.strict,
                        sensitive = _element$props.sensitive,
                        from = _element$props.from;

                    var path = pathProp || from;
                    child = element;
                    match = path ? react_router_1.matchPath(location.pathname, {
                        path: path,
                        exact: exact,
                        strict: strict,
                        sensitive: sensitive
                    }) : route.match;
                    if (match) {
                        index = i;
                    }
                }
            });
            var result = match ? React.cloneElement(child, {
                location: location,
                computedMatch: match
            }) : null;
            return render ? render(result, index, this.props.children) : result;
        }
    }]);

    return Switch;
}(React.Component);

Switch.contextTypes = {
    router: PropTypes.shape({
        route: PropTypes.object.isRequired
    }).isRequired
};
Switch.propTypes = {
    children: PropTypes.node,
    location: PropTypes.object
};
exports.default = Switch;
//# sourceMappingURL=BaseSwitch.jsx.map