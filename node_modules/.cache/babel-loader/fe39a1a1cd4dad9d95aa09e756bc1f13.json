{"ast":null,"code":"/*\n * jQuery FlexSlider v2.7.2\n * Copyright 2012 WooThemes\n * Contributing Author: Tyler Smith\n */\n;\n\n(function ($) {\n  var focused = true; //FlexSlider: Object Instance\n\n  $.flexslider = function (el, options) {\n    var slider = $(el); // making variables public\n    //if rtl value was not passed and html is in rtl..enable it by default.\n\n    if (typeof options.rtl == 'undefined' && $('html').attr('dir') == 'rtl') {\n      options.rtl = true;\n    }\n\n    slider.vars = $.extend({}, $.flexslider.defaults, options);\n    var namespace = slider.vars.namespace,\n        msGesture = window.navigator && window.navigator.msPointerEnabled && window.MSGesture,\n        touch = (\"ontouchstart\" in window || msGesture || window.DocumentTouch && document instanceof DocumentTouch) && slider.vars.touch,\n        // deprecating this idea, as devices are being released with both of these events\n    eventType = \"click touchend MSPointerUp keyup\",\n        watchedEvent = \"\",\n        watchedEventClearTimer,\n        vertical = slider.vars.direction === \"vertical\",\n        reverse = slider.vars.reverse,\n        carousel = slider.vars.itemWidth > 0,\n        fade = slider.vars.animation === \"fade\",\n        asNav = slider.vars.asNavFor !== \"\",\n        methods = {}; // Store a reference to the slider object\n\n    $.data(el, \"flexslider\", slider); // Private slider methods\n\n    methods = {\n      init: function () {\n        slider.animating = false; // Get current slide and make sure it is a number\n\n        slider.currentSlide = parseInt(slider.vars.startAt ? slider.vars.startAt : 0, 10);\n\n        if (isNaN(slider.currentSlide)) {\n          slider.currentSlide = 0;\n        }\n\n        slider.animatingTo = slider.currentSlide;\n        slider.atEnd = slider.currentSlide === 0 || slider.currentSlide === slider.last;\n        slider.containerSelector = slider.vars.selector.substr(0, slider.vars.selector.search(' '));\n        slider.slides = $(slider.vars.selector, slider);\n        slider.container = $(slider.containerSelector, slider);\n        slider.count = slider.slides.length; // SYNC:\n\n        slider.syncExists = $(slider.vars.sync).length > 0; // SLIDE:\n\n        if (slider.vars.animation === \"slide\") {\n          slider.vars.animation = \"swing\";\n        }\n\n        slider.prop = vertical ? \"top\" : slider.vars.rtl ? \"marginRight\" : \"marginLeft\";\n        slider.args = {}; // SLIDESHOW:\n\n        slider.manualPause = false;\n        slider.stopped = false; //PAUSE WHEN INVISIBLE\n\n        slider.started = false;\n        slider.startTimeout = null; // TOUCH/USECSS:\n\n        slider.transitions = !slider.vars.video && !fade && slider.vars.useCSS && function () {\n          var obj = document.createElement('div'),\n              props = ['perspectiveProperty', 'WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];\n\n          for (var i in props) {\n            if (obj.style[props[i]] !== undefined) {\n              slider.pfx = props[i].replace('Perspective', '').toLowerCase();\n              slider.prop = \"-\" + slider.pfx + \"-transform\";\n              return true;\n            }\n          }\n\n          return false;\n        }();\n\n        slider.isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n        slider.ensureAnimationEnd = ''; // CONTROLSCONTAINER:\n\n        if (slider.vars.controlsContainer !== \"\") slider.controlsContainer = $(slider.vars.controlsContainer).length > 0 && $(slider.vars.controlsContainer); // MANUAL:\n\n        if (slider.vars.manualControls !== \"\") slider.manualControls = $(slider.vars.manualControls).length > 0 && $(slider.vars.manualControls); // CUSTOM DIRECTION NAV:\n\n        if (slider.vars.customDirectionNav !== \"\") slider.customDirectionNav = $(slider.vars.customDirectionNav).length === 2 && $(slider.vars.customDirectionNav); // RANDOMIZE:\n\n        if (slider.vars.randomize) {\n          slider.slides.sort(function () {\n            return Math.round(Math.random()) - 0.5;\n          });\n          slider.container.empty().append(slider.slides);\n        }\n\n        slider.doMath(); // INIT\n\n        slider.setup(\"init\"); // CONTROLNAV:\n\n        if (slider.vars.controlNav) {\n          methods.controlNav.setup();\n        } // DIRECTIONNAV:\n\n\n        if (slider.vars.directionNav) {\n          methods.directionNav.setup();\n        } // KEYBOARD:\n\n\n        if (slider.vars.keyboard && ($(slider.containerSelector).length === 1 || slider.vars.multipleKeyboard)) {\n          $(document).bind('keyup', function (event) {\n            var keycode = event.keyCode;\n\n            if (!slider.animating && (keycode === 39 || keycode === 37)) {\n              var target = slider.vars.rtl ? keycode === 37 ? slider.getTarget('next') : keycode === 39 ? slider.getTarget('prev') : false : keycode === 39 ? slider.getTarget('next') : keycode === 37 ? slider.getTarget('prev') : false;\n              slider.flexAnimate(target, slider.vars.pauseOnAction);\n            }\n          });\n        } // MOUSEWHEEL:\n\n\n        if (slider.vars.mousewheel) {\n          slider.bind('mousewheel', function (event, delta, deltaX, deltaY) {\n            event.preventDefault();\n            var target = delta < 0 ? slider.getTarget('next') : slider.getTarget('prev');\n            slider.flexAnimate(target, slider.vars.pauseOnAction);\n          });\n        } // PAUSEPLAY\n\n\n        if (slider.vars.pausePlay) {\n          methods.pausePlay.setup();\n        } //PAUSE WHEN INVISIBLE\n\n\n        if (slider.vars.slideshow && slider.vars.pauseInvisible) {\n          methods.pauseInvisible.init();\n        } // SLIDSESHOW\n\n\n        if (slider.vars.slideshow) {\n          if (slider.vars.pauseOnHover) {\n            slider.hover(function () {\n              if (!slider.manualPlay && !slider.manualPause) {\n                slider.pause();\n              }\n            }, function () {\n              if (!slider.manualPause && !slider.manualPlay && !slider.stopped) {\n                slider.play();\n              }\n            });\n          } // initialize animation\n          //If we're visible, or we don't use PageVisibility API\n\n\n          if (!slider.vars.pauseInvisible || !methods.pauseInvisible.isHidden()) {\n            slider.vars.initDelay > 0 ? slider.startTimeout = setTimeout(slider.play, slider.vars.initDelay) : slider.play();\n          }\n        } // ASNAV:\n\n\n        if (asNav) {\n          methods.asNav.setup();\n        } // TOUCH\n\n\n        if (touch && slider.vars.touch) {\n          methods.touch();\n        } // FADE&&SMOOTHHEIGHT || SLIDE:\n\n\n        if (!fade || fade && slider.vars.smoothHeight) {\n          $(window).bind(\"resize orientationchange focus\", methods.resize);\n        }\n\n        slider.find(\"img\").attr(\"draggable\", \"false\"); // API: start() Callback\n\n        setTimeout(function () {\n          slider.vars.start(slider);\n        }, 200);\n      },\n      asNav: {\n        setup: function () {\n          slider.asNav = true;\n          slider.animatingTo = Math.floor(slider.currentSlide / slider.move);\n          slider.currentItem = slider.currentSlide;\n          slider.slides.removeClass(namespace + \"active-slide\").eq(slider.currentItem).addClass(namespace + \"active-slide\");\n\n          if (!msGesture) {\n            slider.slides.on(eventType, function (e) {\n              e.preventDefault();\n              var $slide = $(this),\n                  target = $slide.index();\n              var posFromX;\n\n              if (slider.vars.rtl) {\n                posFromX = -1 * ($slide.offset().right - $(slider).scrollLeft()); // Find position of slide relative to right of slider container\n              } else {\n                posFromX = $slide.offset().left - $(slider).scrollLeft(); // Find position of slide relative to left of slider container\n              }\n\n              if (posFromX <= 0 && $slide.hasClass(namespace + 'active-slide')) {\n                slider.flexAnimate(slider.getTarget(\"prev\"), true);\n              } else if (!$(slider.vars.asNavFor).data('flexslider').animating && !$slide.hasClass(namespace + \"active-slide\")) {\n                slider.direction = slider.currentItem < target ? \"next\" : \"prev\";\n                slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);\n              }\n            });\n          } else {\n            el._slider = slider;\n            slider.slides.each(function () {\n              var that = this;\n              that._gesture = new MSGesture();\n              that._gesture.target = that;\n              that.addEventListener(\"MSPointerDown\", function (e) {\n                e.preventDefault();\n\n                if (e.currentTarget._gesture) {\n                  e.currentTarget._gesture.addPointer(e.pointerId);\n                }\n              }, false);\n              that.addEventListener(\"MSGestureTap\", function (e) {\n                e.preventDefault();\n                var $slide = $(this),\n                    target = $slide.index();\n\n                if (!$(slider.vars.asNavFor).data('flexslider').animating && !$slide.hasClass('active')) {\n                  slider.direction = slider.currentItem < target ? \"next\" : \"prev\";\n                  slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);\n                }\n              });\n            });\n          }\n        }\n      },\n      controlNav: {\n        setup: function () {\n          if (!slider.manualControls) {\n            methods.controlNav.setupPaging();\n          } else {\n            // MANUALCONTROLS:\n            methods.controlNav.setupManual();\n          }\n        },\n        setupPaging: function () {\n          var type = slider.vars.controlNav === \"thumbnails\" ? 'control-thumbs' : 'control-paging',\n              j = 1,\n              item,\n              slide;\n          slider.controlNavScaffold = $('<ol class=\"' + namespace + 'control-nav ' + namespace + type + '\"></ol>');\n\n          if (slider.pagingCount > 1) {\n            for (var i = 0; i < slider.pagingCount; i++) {\n              slide = slider.slides.eq(i);\n\n              if (undefined === slide.attr('data-thumb-alt')) {\n                slide.attr('data-thumb-alt', '');\n              }\n\n              item = $('<a></a>').attr('href', '#').text(j);\n\n              if (slider.vars.controlNav === \"thumbnails\") {\n                item = $('<img/>').attr('src', slide.attr('data-thumb'));\n              }\n\n              if ('' !== slide.attr('data-thumb-alt')) {\n                item.attr('alt', slide.attr('data-thumb-alt'));\n              }\n\n              if ('thumbnails' === slider.vars.controlNav && true === slider.vars.thumbCaptions) {\n                var captn = slide.attr('data-thumbcaption');\n\n                if ('' !== captn && undefined !== captn) {\n                  var caption = $('<span></span>').addClass(namespace + 'caption').text(captn);\n                  item.append(caption);\n                }\n              }\n\n              var liElement = $('<li>');\n              item.appendTo(liElement);\n              liElement.append('</li>');\n              slider.controlNavScaffold.append(liElement);\n              j++;\n            }\n          } // CONTROLSCONTAINER:\n\n\n          slider.controlsContainer ? $(slider.controlsContainer).append(slider.controlNavScaffold) : slider.append(slider.controlNavScaffold);\n          methods.controlNav.set();\n          methods.controlNav.active();\n          slider.controlNavScaffold.delegate('a, img', eventType, function (event) {\n            event.preventDefault();\n\n            if (watchedEvent === \"\" || watchedEvent === event.type) {\n              var $this = $(this),\n                  target = slider.controlNav.index($this);\n\n              if (!$this.hasClass(namespace + 'active')) {\n                slider.direction = target > slider.currentSlide ? \"next\" : \"prev\";\n                slider.flexAnimate(target, slider.vars.pauseOnAction);\n              }\n            } // setup flags to prevent event duplication\n\n\n            if (watchedEvent === \"\") {\n              watchedEvent = event.type;\n            }\n\n            methods.setToClearWatchedEvent();\n          });\n        },\n        setupManual: function () {\n          slider.controlNav = slider.manualControls;\n          methods.controlNav.active();\n          slider.controlNav.bind(eventType, function (event) {\n            event.preventDefault();\n\n            if (watchedEvent === \"\" || watchedEvent === event.type) {\n              var $this = $(this),\n                  target = slider.controlNav.index($this);\n\n              if (!$this.hasClass(namespace + 'active')) {\n                target > slider.currentSlide ? slider.direction = \"next\" : slider.direction = \"prev\";\n                slider.flexAnimate(target, slider.vars.pauseOnAction);\n              }\n            } // setup flags to prevent event duplication\n\n\n            if (watchedEvent === \"\") {\n              watchedEvent = event.type;\n            }\n\n            methods.setToClearWatchedEvent();\n          });\n        },\n        set: function () {\n          var selector = slider.vars.controlNav === \"thumbnails\" ? 'img' : 'a';\n          slider.controlNav = $('.' + namespace + 'control-nav li ' + selector, slider.controlsContainer ? slider.controlsContainer : slider);\n        },\n        active: function () {\n          slider.controlNav.removeClass(namespace + \"active\").eq(slider.animatingTo).addClass(namespace + \"active\");\n        },\n        update: function (action, pos) {\n          if (slider.pagingCount > 1 && action === \"add\") {\n            slider.controlNavScaffold.append($('<li><a href=\"#\">' + slider.count + '</a></li>'));\n          } else if (slider.pagingCount === 1) {\n            slider.controlNavScaffold.find('li').remove();\n          } else {\n            slider.controlNav.eq(pos).closest('li').remove();\n          }\n\n          methods.controlNav.set();\n          slider.pagingCount > 1 && slider.pagingCount !== slider.controlNav.length ? slider.update(pos, action) : methods.controlNav.active();\n        }\n      },\n      directionNav: {\n        setup: function () {\n          var directionNavScaffold = $('<ul class=\"' + namespace + 'direction-nav\"><li class=\"' + namespace + 'nav-prev\"><a class=\"' + namespace + 'prev\" href=\"#\">' + slider.vars.prevText + '</a></li><li class=\"' + namespace + 'nav-next\"><a class=\"' + namespace + 'next\" href=\"#\">' + slider.vars.nextText + '</a></li></ul>'); // CUSTOM DIRECTION NAV:\n\n          if (slider.customDirectionNav) {\n            slider.directionNav = slider.customDirectionNav; // CONTROLSCONTAINER:\n          } else if (slider.controlsContainer) {\n            $(slider.controlsContainer).append(directionNavScaffold);\n            slider.directionNav = $('.' + namespace + 'direction-nav li a', slider.controlsContainer);\n          } else {\n            slider.append(directionNavScaffold);\n            slider.directionNav = $('.' + namespace + 'direction-nav li a', slider);\n          }\n\n          methods.directionNav.update();\n          slider.directionNav.bind(eventType, function (event) {\n            event.preventDefault();\n            var target;\n\n            if (watchedEvent === \"\" || watchedEvent === event.type) {\n              target = $(this).hasClass(namespace + 'next') ? slider.getTarget('next') : slider.getTarget('prev');\n              slider.flexAnimate(target, slider.vars.pauseOnAction);\n            } // setup flags to prevent event duplication\n\n\n            if (watchedEvent === \"\") {\n              watchedEvent = event.type;\n            }\n\n            methods.setToClearWatchedEvent();\n          });\n        },\n        update: function () {\n          var disabledClass = namespace + 'disabled';\n\n          if (slider.pagingCount === 1) {\n            slider.directionNav.addClass(disabledClass).attr('tabindex', '-1');\n          } else if (!slider.vars.animationLoop) {\n            if (slider.animatingTo === 0) {\n              slider.directionNav.removeClass(disabledClass).filter('.' + namespace + \"prev\").addClass(disabledClass).attr('tabindex', '-1');\n            } else if (slider.animatingTo === slider.last) {\n              slider.directionNav.removeClass(disabledClass).filter('.' + namespace + \"next\").addClass(disabledClass).attr('tabindex', '-1');\n            } else {\n              slider.directionNav.removeClass(disabledClass).removeAttr('tabindex');\n            }\n          } else {\n            slider.directionNav.removeClass(disabledClass).removeAttr('tabindex');\n          }\n        }\n      },\n      pausePlay: {\n        setup: function () {\n          var pausePlayScaffold = $('<div class=\"' + namespace + 'pauseplay\"><a href=\"#\"></a></div>'); // CONTROLSCONTAINER:\n\n          if (slider.controlsContainer) {\n            slider.controlsContainer.append(pausePlayScaffold);\n            slider.pausePlay = $('.' + namespace + 'pauseplay a', slider.controlsContainer);\n          } else {\n            slider.append(pausePlayScaffold);\n            slider.pausePlay = $('.' + namespace + 'pauseplay a', slider);\n          }\n\n          methods.pausePlay.update(slider.vars.slideshow ? namespace + 'pause' : namespace + 'play');\n          slider.pausePlay.bind(eventType, function (event) {\n            event.preventDefault();\n\n            if (watchedEvent === \"\" || watchedEvent === event.type) {\n              if ($(this).hasClass(namespace + 'pause')) {\n                slider.manualPause = true;\n                slider.manualPlay = false;\n                slider.pause();\n              } else {\n                slider.manualPause = false;\n                slider.manualPlay = true;\n                slider.play();\n              }\n            } // setup flags to prevent event duplication\n\n\n            if (watchedEvent === \"\") {\n              watchedEvent = event.type;\n            }\n\n            methods.setToClearWatchedEvent();\n          });\n        },\n        update: function (state) {\n          state === \"play\" ? slider.pausePlay.removeClass(namespace + 'pause').addClass(namespace + 'play').html(slider.vars.playText) : slider.pausePlay.removeClass(namespace + 'play').addClass(namespace + 'pause').html(slider.vars.pauseText);\n        }\n      },\n      touch: function () {\n        var startX,\n            startY,\n            offset,\n            cwidth,\n            dx,\n            startT,\n            onTouchStart,\n            onTouchMove,\n            onTouchEnd,\n            scrolling = false,\n            localX = 0,\n            localY = 0,\n            accDx = 0;\n\n        if (!msGesture) {\n          onTouchStart = function (e) {\n            if (slider.animating) {\n              e.preventDefault();\n            } else if (window.navigator.msPointerEnabled || e.touches.length === 1) {\n              slider.pause(); // CAROUSEL:\n\n              cwidth = vertical ? slider.h : slider.w;\n              startT = Number(new Date()); // CAROUSEL:\n              // Local vars for X and Y points.\n\n              localX = e.touches[0].pageX;\n              localY = e.touches[0].pageY;\n              offset = carousel && reverse && slider.animatingTo === slider.last ? 0 : carousel && reverse ? slider.limit - (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo : carousel && slider.currentSlide === slider.last ? slider.limit : carousel ? (slider.itemW + slider.vars.itemMargin) * slider.move * slider.currentSlide : reverse ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;\n              startX = vertical ? localY : localX;\n              startY = vertical ? localX : localY;\n              el.addEventListener('touchmove', onTouchMove, false);\n              el.addEventListener('touchend', onTouchEnd, false);\n            }\n          };\n\n          onTouchMove = function (e) {\n            // Local vars for X and Y points.\n            localX = e.touches[0].pageX;\n            localY = e.touches[0].pageY;\n            dx = vertical ? startX - localY : (slider.vars.rtl ? -1 : 1) * (startX - localX);\n            scrolling = vertical ? Math.abs(dx) < Math.abs(localX - startY) : Math.abs(dx) < Math.abs(localY - startY);\n            var fxms = 500;\n\n            if (!scrolling || Number(new Date()) - startT > fxms) {\n              e.preventDefault();\n\n              if (!fade && slider.transitions) {\n                if (!slider.vars.animationLoop) {\n                  dx = dx / (slider.currentSlide === 0 && dx < 0 || slider.currentSlide === slider.last && dx > 0 ? Math.abs(dx) / cwidth + 2 : 1);\n                }\n\n                slider.setProps(offset + dx, \"setTouch\");\n              }\n            }\n          };\n\n          onTouchEnd = function (e) {\n            // finish the touch by undoing the touch session\n            el.removeEventListener('touchmove', onTouchMove, false);\n\n            if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {\n              var updateDx = reverse ? -dx : dx,\n                  target = updateDx > 0 ? slider.getTarget('next') : slider.getTarget('prev');\n\n              if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth / 2)) {\n                slider.flexAnimate(target, slider.vars.pauseOnAction);\n              } else {\n                if (!fade) {\n                  slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true);\n                }\n              }\n            }\n\n            el.removeEventListener('touchend', onTouchEnd, false);\n            startX = null;\n            startY = null;\n            dx = null;\n            offset = null;\n          };\n\n          el.addEventListener('touchstart', onTouchStart, false);\n        } else {\n          el.style.msTouchAction = \"none\";\n          el._gesture = new MSGesture();\n          el._gesture.target = el;\n          el.addEventListener(\"MSPointerDown\", onMSPointerDown, false);\n          el._slider = slider;\n          el.addEventListener(\"MSGestureChange\", onMSGestureChange, false);\n          el.addEventListener(\"MSGestureEnd\", onMSGestureEnd, false);\n\n          function onMSPointerDown(e) {\n            e.stopPropagation();\n\n            if (slider.animating) {\n              e.preventDefault();\n            } else {\n              slider.pause();\n\n              el._gesture.addPointer(e.pointerId);\n\n              accDx = 0;\n              cwidth = vertical ? slider.h : slider.w;\n              startT = Number(new Date()); // CAROUSEL:\n\n              offset = carousel && reverse && slider.animatingTo === slider.last ? 0 : carousel && reverse ? slider.limit - (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo : carousel && slider.currentSlide === slider.last ? slider.limit : carousel ? (slider.itemW + slider.vars.itemMargin) * slider.move * slider.currentSlide : reverse ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;\n            }\n          }\n\n          function onMSGestureChange(e) {\n            e.stopPropagation();\n            var slider = e.target._slider;\n\n            if (!slider) {\n              return;\n            }\n\n            var transX = -e.translationX,\n                transY = -e.translationY; //Accumulate translations.\n\n            accDx = accDx + (vertical ? transY : transX);\n            dx = (slider.vars.rtl ? -1 : 1) * accDx;\n            scrolling = vertical ? Math.abs(accDx) < Math.abs(-transX) : Math.abs(accDx) < Math.abs(-transY);\n\n            if (e.detail === e.MSGESTURE_FLAG_INERTIA) {\n              setImmediate(function () {\n                el._gesture.stop();\n              });\n              return;\n            }\n\n            if (!scrolling || Number(new Date()) - startT > 500) {\n              e.preventDefault();\n\n              if (!fade && slider.transitions) {\n                if (!slider.vars.animationLoop) {\n                  dx = accDx / (slider.currentSlide === 0 && accDx < 0 || slider.currentSlide === slider.last && accDx > 0 ? Math.abs(accDx) / cwidth + 2 : 1);\n                }\n\n                slider.setProps(offset + dx, \"setTouch\");\n              }\n            }\n          }\n\n          function onMSGestureEnd(e) {\n            e.stopPropagation();\n            var slider = e.target._slider;\n\n            if (!slider) {\n              return;\n            }\n\n            if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {\n              var updateDx = reverse ? -dx : dx,\n                  target = updateDx > 0 ? slider.getTarget('next') : slider.getTarget('prev');\n\n              if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth / 2)) {\n                slider.flexAnimate(target, slider.vars.pauseOnAction);\n              } else {\n                if (!fade) {\n                  slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true);\n                }\n              }\n            }\n\n            startX = null;\n            startY = null;\n            dx = null;\n            offset = null;\n            accDx = 0;\n          }\n        }\n      },\n      resize: function () {\n        if (!slider.animating && slider.is(':visible')) {\n          if (!carousel) {\n            slider.doMath();\n          }\n\n          if (fade) {\n            // SMOOTH HEIGHT:\n            methods.smoothHeight();\n          } else if (carousel) {\n            //CAROUSEL:\n            slider.slides.width(slider.computedW);\n            slider.update(slider.pagingCount);\n            slider.setProps();\n          } else if (vertical) {\n            //VERTICAL:\n            slider.viewport.height(slider.h);\n            slider.setProps(slider.h, \"setTotal\");\n          } else {\n            // SMOOTH HEIGHT:\n            if (slider.vars.smoothHeight) {\n              methods.smoothHeight();\n            }\n\n            slider.newSlides.width(slider.computedW);\n            slider.setProps(slider.computedW, \"setTotal\");\n          }\n        }\n      },\n      smoothHeight: function (dur) {\n        if (!vertical || fade) {\n          var $obj = fade ? slider : slider.viewport;\n          dur ? $obj.animate({\n            \"height\": slider.slides.eq(slider.animatingTo).innerHeight()\n          }, dur) : $obj.innerHeight(slider.slides.eq(slider.animatingTo).innerHeight());\n        }\n      },\n      sync: function (action) {\n        var $obj = $(slider.vars.sync).data(\"flexslider\"),\n            target = slider.animatingTo;\n\n        switch (action) {\n          case \"animate\":\n            $obj.flexAnimate(target, slider.vars.pauseOnAction, false, true);\n            break;\n\n          case \"play\":\n            if (!$obj.playing && !$obj.asNav) {\n              $obj.play();\n            }\n\n            break;\n\n          case \"pause\":\n            $obj.pause();\n            break;\n        }\n      },\n      uniqueID: function ($clone) {\n        // Append _clone to current level and children elements with id attributes\n        $clone.filter('[id]').add($clone.find('[id]')).each(function () {\n          var $this = $(this);\n          $this.attr('id', $this.attr('id') + '_clone');\n        });\n        return $clone;\n      },\n      pauseInvisible: {\n        visProp: null,\n        init: function () {\n          var visProp = methods.pauseInvisible.getHiddenProp();\n\n          if (visProp) {\n            var evtname = visProp.replace(/[H|h]idden/, '') + 'visibilitychange';\n            document.addEventListener(evtname, function () {\n              if (methods.pauseInvisible.isHidden()) {\n                if (slider.startTimeout) {\n                  clearTimeout(slider.startTimeout); //If clock is ticking, stop timer and prevent from starting while invisible\n                } else {\n                  slider.pause(); //Or just pause\n                }\n              } else {\n                if (slider.started) {\n                  slider.play(); //Initiated before, just play\n                } else {\n                  if (slider.vars.initDelay > 0) {\n                    setTimeout(slider.play, slider.vars.initDelay);\n                  } else {\n                    slider.play(); //Didn't init before: simply init or wait for it\n                  }\n                }\n              }\n            });\n          }\n        },\n        isHidden: function () {\n          var prop = methods.pauseInvisible.getHiddenProp();\n\n          if (!prop) {\n            return false;\n          }\n\n          return document[prop];\n        },\n        getHiddenProp: function () {\n          var prefixes = ['webkit', 'moz', 'ms', 'o']; // if 'hidden' is natively supported just return it\n\n          if ('hidden' in document) {\n            return 'hidden';\n          } // otherwise loop over all the known prefixes until we find one\n\n\n          for (var i = 0; i < prefixes.length; i++) {\n            if (prefixes[i] + 'Hidden' in document) {\n              return prefixes[i] + 'Hidden';\n            }\n          } // otherwise it's not supported\n\n\n          return null;\n        }\n      },\n      setToClearWatchedEvent: function () {\n        clearTimeout(watchedEventClearTimer);\n        watchedEventClearTimer = setTimeout(function () {\n          watchedEvent = \"\";\n        }, 3000);\n      }\n    }; // public methods\n\n    slider.flexAnimate = function (target, pause, override, withSync, fromNav) {\n      if (!slider.vars.animationLoop && target !== slider.currentSlide) {\n        slider.direction = target > slider.currentSlide ? \"next\" : \"prev\";\n      }\n\n      if (asNav && slider.pagingCount === 1) slider.direction = slider.currentItem < target ? \"next\" : \"prev\";\n\n      if (!slider.animating && (slider.canAdvance(target, fromNav) || override) && slider.is(\":visible\")) {\n        if (asNav && withSync) {\n          var master = $(slider.vars.asNavFor).data('flexslider');\n          slider.atEnd = target === 0 || target === slider.count - 1;\n          master.flexAnimate(target, true, false, true, fromNav);\n          slider.direction = slider.currentItem < target ? \"next\" : \"prev\";\n          master.direction = slider.direction;\n\n          if (Math.ceil((target + 1) / slider.visible) - 1 !== slider.currentSlide && target !== 0) {\n            slider.currentItem = target;\n            slider.slides.removeClass(namespace + \"active-slide\").eq(target).addClass(namespace + \"active-slide\");\n            target = Math.floor(target / slider.visible);\n          } else {\n            slider.currentItem = target;\n            slider.slides.removeClass(namespace + \"active-slide\").eq(target).addClass(namespace + \"active-slide\");\n            return false;\n          }\n        }\n\n        slider.animating = true;\n        slider.animatingTo = target; // SLIDESHOW:\n\n        if (pause) {\n          slider.pause();\n        } // API: before() animation Callback\n\n\n        slider.vars.before(slider); // SYNC:\n\n        if (slider.syncExists && !fromNav) {\n          methods.sync(\"animate\");\n        } // CONTROLNAV\n\n\n        if (slider.vars.controlNav) {\n          methods.controlNav.active();\n        } // !CAROUSEL:\n        // CANDIDATE: slide active class (for add/remove slide)\n\n\n        if (!carousel) {\n          slider.slides.removeClass(namespace + 'active-slide').eq(target).addClass(namespace + 'active-slide');\n        } // INFINITE LOOP:\n        // CANDIDATE: atEnd\n\n\n        slider.atEnd = target === 0 || target === slider.last; // DIRECTIONNAV:\n\n        if (slider.vars.directionNav) {\n          methods.directionNav.update();\n        }\n\n        if (target === slider.last) {\n          // API: end() of cycle Callback\n          slider.vars.end(slider); // SLIDESHOW && !INFINITE LOOP:\n\n          if (!slider.vars.animationLoop) {\n            slider.pause();\n          }\n        } // SLIDE:\n\n\n        if (!fade) {\n          var dimension = vertical ? slider.slides.filter(':first').height() : slider.computedW,\n              margin,\n              slideString,\n              calcNext; // INFINITE LOOP / REVERSE:\n\n          if (carousel) {\n            margin = slider.vars.itemMargin;\n            calcNext = (slider.itemW + margin) * slider.move * slider.animatingTo;\n            slideString = calcNext > slider.limit && slider.visible !== 1 ? slider.limit : calcNext;\n          } else if (slider.currentSlide === 0 && target === slider.count - 1 && slider.vars.animationLoop && slider.direction !== \"next\") {\n            slideString = reverse ? (slider.count + slider.cloneOffset) * dimension : 0;\n          } else if (slider.currentSlide === slider.last && target === 0 && slider.vars.animationLoop && slider.direction !== \"prev\") {\n            slideString = reverse ? 0 : (slider.count + 1) * dimension;\n          } else {\n            slideString = reverse ? (slider.count - 1 - target + slider.cloneOffset) * dimension : (target + slider.cloneOffset) * dimension;\n          }\n\n          slider.setProps(slideString, \"\", slider.vars.animationSpeed);\n\n          if (slider.transitions) {\n            if (!slider.vars.animationLoop || !slider.atEnd) {\n              slider.animating = false;\n              slider.currentSlide = slider.animatingTo;\n            } // Unbind previous transitionEnd events and re-bind new transitionEnd event\n\n\n            slider.container.unbind(\"webkitTransitionEnd transitionend\");\n            slider.container.bind(\"webkitTransitionEnd transitionend\", function () {\n              clearTimeout(slider.ensureAnimationEnd);\n              slider.wrapup(dimension);\n            }); // Insurance for the ever-so-fickle transitionEnd event\n\n            clearTimeout(slider.ensureAnimationEnd);\n            slider.ensureAnimationEnd = setTimeout(function () {\n              slider.wrapup(dimension);\n            }, slider.vars.animationSpeed + 100);\n          } else {\n            slider.container.animate(slider.args, slider.vars.animationSpeed, slider.vars.easing, function () {\n              slider.wrapup(dimension);\n            });\n          }\n        } else {\n          // FADE:\n          if (!touch) {\n            slider.slides.eq(slider.currentSlide).css({\n              \"zIndex\": 1\n            }).animate({\n              \"opacity\": 0\n            }, slider.vars.animationSpeed, slider.vars.easing);\n            slider.slides.eq(target).css({\n              \"zIndex\": 2\n            }).animate({\n              \"opacity\": 1\n            }, slider.vars.animationSpeed, slider.vars.easing, slider.wrapup);\n          } else {\n            slider.slides.eq(slider.currentSlide).css({\n              \"opacity\": 0,\n              \"zIndex\": 1\n            });\n            slider.slides.eq(target).css({\n              \"opacity\": 1,\n              \"zIndex\": 2\n            });\n            slider.wrapup(dimension);\n          }\n        } // SMOOTH HEIGHT:\n\n\n        if (slider.vars.smoothHeight) {\n          methods.smoothHeight(slider.vars.animationSpeed);\n        }\n      }\n    };\n\n    slider.wrapup = function (dimension) {\n      // SLIDE:\n      if (!fade && !carousel) {\n        if (slider.currentSlide === 0 && slider.animatingTo === slider.last && slider.vars.animationLoop) {\n          slider.setProps(dimension, \"jumpEnd\");\n        } else if (slider.currentSlide === slider.last && slider.animatingTo === 0 && slider.vars.animationLoop) {\n          slider.setProps(dimension, \"jumpStart\");\n        }\n      }\n\n      slider.animating = false;\n      slider.currentSlide = slider.animatingTo; // API: after() animation Callback\n\n      slider.vars.after(slider);\n    }; // SLIDESHOW:\n\n\n    slider.animateSlides = function () {\n      if (!slider.animating && focused) {\n        slider.flexAnimate(slider.getTarget(\"next\"));\n      }\n    }; // SLIDESHOW:\n\n\n    slider.pause = function () {\n      clearInterval(slider.animatedSlides);\n      slider.animatedSlides = null;\n      slider.playing = false; // PAUSEPLAY:\n\n      if (slider.vars.pausePlay) {\n        methods.pausePlay.update(\"play\");\n      } // SYNC:\n\n\n      if (slider.syncExists) {\n        methods.sync(\"pause\");\n      }\n    }; // SLIDESHOW:\n\n\n    slider.play = function () {\n      if (slider.playing) {\n        clearInterval(slider.animatedSlides);\n      }\n\n      slider.animatedSlides = slider.animatedSlides || setInterval(slider.animateSlides, slider.vars.slideshowSpeed);\n      slider.started = slider.playing = true; // PAUSEPLAY:\n\n      if (slider.vars.pausePlay) {\n        methods.pausePlay.update(\"pause\");\n      } // SYNC:\n\n\n      if (slider.syncExists) {\n        methods.sync(\"play\");\n      }\n    }; // STOP:\n\n\n    slider.stop = function () {\n      slider.pause();\n      slider.stopped = true;\n    };\n\n    slider.canAdvance = function (target, fromNav) {\n      // ASNAV:\n      var last = asNav ? slider.pagingCount - 1 : slider.last;\n      return fromNav ? true : asNav && slider.currentItem === slider.count - 1 && target === 0 && slider.direction === \"prev\" ? true : asNav && slider.currentItem === 0 && target === slider.pagingCount - 1 && slider.direction !== \"next\" ? false : target === slider.currentSlide && !asNav ? false : slider.vars.animationLoop ? true : slider.atEnd && slider.currentSlide === 0 && target === last && slider.direction !== \"next\" ? false : slider.atEnd && slider.currentSlide === last && target === 0 && slider.direction === \"next\" ? false : true;\n    };\n\n    slider.getTarget = function (dir) {\n      slider.direction = dir;\n\n      if (dir === \"next\") {\n        return slider.currentSlide === slider.last ? 0 : slider.currentSlide + 1;\n      } else {\n        return slider.currentSlide === 0 ? slider.last : slider.currentSlide - 1;\n      }\n    }; // SLIDE:\n\n\n    slider.setProps = function (pos, special, dur) {\n      var target = function () {\n        var posCheck = pos ? pos : (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo,\n            posCalc = function () {\n          if (carousel) {\n            return special === \"setTouch\" ? pos : reverse && slider.animatingTo === slider.last ? 0 : reverse ? slider.limit - (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo : slider.animatingTo === slider.last ? slider.limit : posCheck;\n          } else {\n            switch (special) {\n              case \"setTotal\":\n                return reverse ? (slider.count - 1 - slider.currentSlide + slider.cloneOffset) * pos : (slider.currentSlide + slider.cloneOffset) * pos;\n\n              case \"setTouch\":\n                return reverse ? pos : pos;\n\n              case \"jumpEnd\":\n                return reverse ? pos : slider.count * pos;\n\n              case \"jumpStart\":\n                return reverse ? slider.count * pos : pos;\n\n              default:\n                return pos;\n            }\n          }\n        }();\n\n        return posCalc * (slider.vars.rtl ? 1 : -1) + \"px\";\n      }();\n\n      if (slider.transitions) {\n        if (slider.isFirefox) {\n          target = vertical ? \"translate3d(0,\" + target + \",0)\" : \"translate3d(\" + (parseInt(target) + 'px') + \",0,0)\";\n        } else {\n          target = vertical ? \"translate3d(0,\" + target + \",0)\" : \"translate3d(\" + ((slider.vars.rtl ? -1 : 1) * parseInt(target) + 'px') + \",0,0)\";\n        }\n\n        dur = dur !== undefined ? dur / 1000 + \"s\" : \"0s\";\n        slider.container.css(\"-\" + slider.pfx + \"-transition-duration\", dur);\n        slider.container.css(\"transition-duration\", dur);\n      }\n\n      slider.args[slider.prop] = target;\n\n      if (slider.transitions || dur === undefined) {\n        slider.container.css(slider.args);\n      }\n\n      slider.container.css('transform', target);\n    };\n\n    slider.setup = function (type) {\n      // SLIDE:\n      if (!fade) {\n        var sliderOffset, arr;\n\n        if (type === \"init\") {\n          slider.viewport = $('<div class=\"' + namespace + 'viewport\"></div>').css({\n            \"overflow\": \"hidden\",\n            \"position\": \"relative\"\n          }).appendTo(slider).append(slider.container); // INFINITE LOOP:\n\n          slider.cloneCount = 0;\n          slider.cloneOffset = 0; // REVERSE:\n\n          if (reverse) {\n            arr = $.makeArray(slider.slides).reverse();\n            slider.slides = $(arr);\n            slider.container.empty().append(slider.slides);\n          }\n        } // INFINITE LOOP && !CAROUSEL:\n\n\n        if (slider.vars.animationLoop && !carousel) {\n          slider.cloneCount = 2;\n          slider.cloneOffset = 1; // clear out old clones\n\n          if (type !== \"init\") {\n            slider.container.find('.clone').remove();\n          }\n\n          slider.container.append(methods.uniqueID(slider.slides.first().clone().addClass('clone')).attr('aria-hidden', 'true')).prepend(methods.uniqueID(slider.slides.last().clone().addClass('clone')).attr('aria-hidden', 'true'));\n        }\n\n        slider.newSlides = $(slider.vars.selector, slider);\n        sliderOffset = reverse ? slider.count - 1 - slider.currentSlide + slider.cloneOffset : slider.currentSlide + slider.cloneOffset; // VERTICAL:\n\n        if (vertical && !carousel) {\n          slider.container.height((slider.count + slider.cloneCount) * 200 + \"%\").css(\"position\", \"absolute\").width(\"100%\");\n          setTimeout(function () {\n            slider.newSlides.css({\n              \"display\": \"block\"\n            });\n            slider.doMath();\n            slider.viewport.height(slider.h);\n            slider.setProps(sliderOffset * slider.h, \"init\");\n          }, type === \"init\" ? 100 : 0);\n        } else {\n          slider.container.width((slider.count + slider.cloneCount) * 200 + \"%\");\n          slider.setProps(sliderOffset * slider.computedW, \"init\");\n          setTimeout(function () {\n            slider.doMath();\n\n            if (slider.vars.rtl) {\n              if (slider.isFirefox) {\n                slider.newSlides.css({\n                  \"width\": slider.computedW,\n                  \"marginRight\": slider.computedM,\n                  \"float\": \"right\",\n                  \"display\": \"block\"\n                });\n              } else {\n                slider.newSlides.css({\n                  \"width\": slider.computedW,\n                  \"marginRight\": slider.computedM,\n                  \"float\": \"left\",\n                  \"display\": \"block\"\n                });\n              }\n            } else {\n              slider.newSlides.css({\n                \"width\": slider.computedW,\n                \"marginRight\": slider.computedM,\n                \"float\": \"left\",\n                \"display\": \"block\"\n              });\n            } // SMOOTH HEIGHT:\n\n\n            if (slider.vars.smoothHeight) {\n              methods.smoothHeight();\n            }\n          }, type === \"init\" ? 100 : 0);\n        }\n      } else {\n        // FADE:\n        if (slider.vars.rtl) {\n          slider.slides.css({\n            \"width\": \"100%\",\n            \"float\": 'right',\n            \"marginLeft\": \"-100%\",\n            \"position\": \"relative\"\n          });\n        } else {\n          slider.slides.css({\n            \"width\": \"100%\",\n            \"float\": 'left',\n            \"marginRight\": \"-100%\",\n            \"position\": \"relative\"\n          });\n        }\n\n        if (type === \"init\") {\n          if (!touch) {\n            //slider.slides.eq(slider.currentSlide).fadeIn(slider.vars.animationSpeed, slider.vars.easing);\n            if (slider.vars.fadeFirstSlide == false) {\n              slider.slides.css({\n                \"opacity\": 0,\n                \"display\": \"block\",\n                \"zIndex\": 1\n              }).eq(slider.currentSlide).css({\n                \"zIndex\": 2\n              }).css({\n                \"opacity\": 1\n              });\n            } else {\n              slider.slides.css({\n                \"opacity\": 0,\n                \"display\": \"block\",\n                \"zIndex\": 1\n              }).eq(slider.currentSlide).css({\n                \"zIndex\": 2\n              }).animate({\n                \"opacity\": 1\n              }, slider.vars.animationSpeed, slider.vars.easing);\n            }\n          } else {\n            slider.slides.css({\n              \"opacity\": 0,\n              \"display\": \"block\",\n              \"webkitTransition\": \"opacity \" + slider.vars.animationSpeed / 1000 + \"s ease\",\n              \"zIndex\": 1\n            }).eq(slider.currentSlide).css({\n              \"opacity\": 1,\n              \"zIndex\": 2\n            });\n          }\n        } // SMOOTH HEIGHT:\n\n\n        if (slider.vars.smoothHeight) {\n          methods.smoothHeight();\n        }\n      } // !CAROUSEL:\n      // CANDIDATE: active slide\n\n\n      if (!carousel) {\n        slider.slides.removeClass(namespace + \"active-slide\").eq(slider.currentSlide).addClass(namespace + \"active-slide\");\n      } //FlexSlider: init() Callback\n\n\n      slider.vars.init(slider);\n    };\n\n    slider.doMath = function () {\n      var slide = slider.slides.first(),\n          slideMargin = slider.vars.itemMargin,\n          minItems = slider.vars.minItems,\n          maxItems = slider.vars.maxItems;\n      slider.w = slider.viewport === undefined ? slider.width() : slider.viewport.width();\n\n      if (slider.isFirefox) {\n        slider.w = slider.width();\n      }\n\n      slider.h = slide.height();\n      slider.boxPadding = slide.outerWidth() - slide.width(); // CAROUSEL:\n\n      if (carousel) {\n        slider.itemT = slider.vars.itemWidth + slideMargin;\n        slider.itemM = slideMargin;\n        slider.minW = minItems ? minItems * slider.itemT : slider.w;\n        slider.maxW = maxItems ? maxItems * slider.itemT - slideMargin : slider.w;\n        slider.itemW = slider.minW > slider.w ? (slider.w - slideMargin * (minItems - 1)) / minItems : slider.maxW < slider.w ? (slider.w - slideMargin * (maxItems - 1)) / maxItems : slider.vars.itemWidth > slider.w ? slider.w : slider.vars.itemWidth;\n        slider.visible = Math.floor(slider.w / slider.itemW);\n        slider.move = slider.vars.move > 0 && slider.vars.move < slider.visible ? slider.vars.move : slider.visible;\n        slider.pagingCount = Math.ceil((slider.count - slider.visible) / slider.move + 1);\n        slider.last = slider.pagingCount - 1;\n        slider.limit = slider.pagingCount === 1 ? 0 : slider.vars.itemWidth > slider.w ? slider.itemW * (slider.count - 1) + slideMargin * (slider.count - 1) : (slider.itemW + slideMargin) * slider.count - slider.w - slideMargin;\n      } else {\n        slider.itemW = slider.w;\n        slider.itemM = slideMargin;\n        slider.pagingCount = slider.count;\n        slider.last = slider.count - 1;\n      }\n\n      slider.computedW = slider.itemW - slider.boxPadding;\n      slider.computedM = slider.itemM;\n    };\n\n    slider.update = function (pos, action) {\n      slider.doMath(); // update currentSlide and slider.animatingTo if necessary\n\n      if (!carousel) {\n        if (pos < slider.currentSlide) {\n          slider.currentSlide += 1;\n        } else if (pos <= slider.currentSlide && pos !== 0) {\n          slider.currentSlide -= 1;\n        }\n\n        slider.animatingTo = slider.currentSlide;\n      } // update controlNav\n\n\n      if (slider.vars.controlNav && !slider.manualControls) {\n        if (action === \"add\" && !carousel || slider.pagingCount > slider.controlNav.length) {\n          methods.controlNav.update(\"add\");\n        } else if (action === \"remove\" && !carousel || slider.pagingCount < slider.controlNav.length) {\n          if (carousel && slider.currentSlide > slider.last) {\n            slider.currentSlide -= 1;\n            slider.animatingTo -= 1;\n          }\n\n          methods.controlNav.update(\"remove\", slider.last);\n        }\n      } // update directionNav\n\n\n      if (slider.vars.directionNav) {\n        methods.directionNav.update();\n      }\n    };\n\n    slider.addSlide = function (obj, pos) {\n      var $obj = $(obj);\n      slider.count += 1;\n      slider.last = slider.count - 1; // append new slide\n\n      if (vertical && reverse) {\n        pos !== undefined ? slider.slides.eq(slider.count - pos).after($obj) : slider.container.prepend($obj);\n      } else {\n        pos !== undefined ? slider.slides.eq(pos).before($obj) : slider.container.append($obj);\n      } // update currentSlide, animatingTo, controlNav, and directionNav\n\n\n      slider.update(pos, \"add\"); // update slider.slides\n\n      slider.slides = $(slider.vars.selector + ':not(.clone)', slider); // re-setup the slider to accomdate new slide\n\n      slider.setup(); //FlexSlider: added() Callback\n\n      slider.vars.added(slider);\n    };\n\n    slider.removeSlide = function (obj) {\n      var pos = isNaN(obj) ? slider.slides.index($(obj)) : obj; // update count\n\n      slider.count -= 1;\n      slider.last = slider.count - 1; // remove slide\n\n      if (isNaN(obj)) {\n        $(obj, slider.slides).remove();\n      } else {\n        vertical && reverse ? slider.slides.eq(slider.last).remove() : slider.slides.eq(obj).remove();\n      } // update currentSlide, animatingTo, controlNav, and directionNav\n\n\n      slider.doMath();\n      slider.update(pos, \"remove\"); // update slider.slides\n\n      slider.slides = $(slider.vars.selector + ':not(.clone)', slider); // re-setup the slider to accomdate new slide\n\n      slider.setup(); // FlexSlider: removed() Callback\n\n      slider.vars.removed(slider);\n    }; //FlexSlider: Initialize\n\n\n    methods.init();\n  }; // Ensure the slider isn't focussed if the window loses focus.\n\n\n  $(window).blur(function (e) {\n    focused = false;\n  }).focus(function (e) {\n    focused = true;\n  }); //FlexSlider: Default Settings\n\n  $.flexslider.defaults = {\n    namespace: \"flex-\",\n    //{NEW} String: Prefix string attached to the class of every element generated by the plugin\n    selector: \".slides > li\",\n    //{NEW} Selector: Must match a simple pattern. '{container} > {slide}' -- Ignore pattern at your own peril\n    animation: \"fade\",\n    //String: Select your animation type, \"fade\" or \"slide\"\n    easing: \"swing\",\n    //{NEW} String: Determines the easing method used in jQuery transitions. jQuery easing plugin is supported!\n    direction: \"horizontal\",\n    //String: Select the sliding direction, \"horizontal\" or \"vertical\"\n    reverse: false,\n    //{NEW} Boolean: Reverse the animation direction\n    animationLoop: true,\n    //Boolean: Should the animation loop? If false, directionNav will received \"disable\" classes at either end\n    smoothHeight: false,\n    //{NEW} Boolean: Allow height of the slider to animate smoothly in horizontal mode\n    startAt: 0,\n    //Integer: The slide that the slider should start on. Array notation (0 = first slide)\n    slideshow: true,\n    //Boolean: Animate slider automatically\n    slideshowSpeed: 7000,\n    //Integer: Set the speed of the slideshow cycling, in milliseconds\n    animationSpeed: 600,\n    //Integer: Set the speed of animations, in milliseconds\n    initDelay: 0,\n    //{NEW} Integer: Set an initialization delay, in milliseconds\n    randomize: false,\n    //Boolean: Randomize slide order\n    fadeFirstSlide: true,\n    //Boolean: Fade in the first slide when animation type is \"fade\"\n    thumbCaptions: false,\n    //Boolean: Whether or not to put captions on thumbnails when using the \"thumbnails\" controlNav.\n    // Usability features\n    pauseOnAction: true,\n    //Boolean: Pause the slideshow when interacting with control elements, highly recommended.\n    pauseOnHover: false,\n    //Boolean: Pause the slideshow when hovering over slider, then resume when no longer hovering\n    pauseInvisible: true,\n    //{NEW} Boolean: Pause the slideshow when tab is invisible, resume when visible. Provides better UX, lower CPU usage.\n    useCSS: true,\n    //{NEW} Boolean: Slider will use CSS3 transitions if available\n    touch: true,\n    //{NEW} Boolean: Allow touch swipe navigation of the slider on touch-enabled devices\n    video: false,\n    //{NEW} Boolean: If using video in the slider, will prevent CSS3 3D Transforms to avoid graphical glitches\n    // Primary Controls\n    controlNav: true,\n    //Boolean: Create navigation for paging control of each slide? Note: Leave true for manualControls usage\n    directionNav: true,\n    //Boolean: Create navigation for previous/next navigation? (true/false)\n    prevText: \"Previous\",\n    //String: Set the text for the \"previous\" directionNav item\n    nextText: \"Next\",\n    //String: Set the text for the \"next\" directionNav item\n    // Secondary Navigation\n    keyboard: true,\n    //Boolean: Allow slider navigating via keyboard left/right keys\n    multipleKeyboard: false,\n    //{NEW} Boolean: Allow keyboard navigation to affect multiple sliders. Default behavior cuts out keyboard navigation with more than one slider present.\n    mousewheel: false,\n    //{UPDATED} Boolean: Requires jquery.mousewheel.js (https://github.com/brandonaaron/jquery-mousewheel) - Allows slider navigating via mousewheel\n    pausePlay: false,\n    //Boolean: Create pause/play dynamic element\n    pauseText: \"Pause\",\n    //String: Set the text for the \"pause\" pausePlay item\n    playText: \"Play\",\n    //String: Set the text for the \"play\" pausePlay item\n    // Special properties\n    controlsContainer: \"\",\n    //{UPDATED} jQuery Object/Selector: Declare which container the navigation elements should be appended too. Default container is the FlexSlider element. Example use would be $(\".flexslider-container\"). Property is ignored if given element is not found.\n    manualControls: \"\",\n    //{UPDATED} jQuery Object/Selector: Declare custom control navigation. Examples would be $(\".flex-control-nav li\") or \"#tabs-nav li img\", etc. The number of elements in your controlNav should match the number of slides/tabs.\n    customDirectionNav: \"\",\n    //{NEW} jQuery Object/Selector: Custom prev / next button. Must be two jQuery elements. In order to make the events work they have to have the classes \"prev\" and \"next\" (plus namespace)\n    sync: \"\",\n    //{NEW} Selector: Mirror the actions performed on this slider with another slider. Use with care.\n    asNavFor: \"\",\n    //{NEW} Selector: Internal property exposed for turning the slider into a thumbnail navigation for another slider\n    // Carousel Options\n    itemWidth: 0,\n    //{NEW} Integer: Box-model width of individual carousel items, including horizontal borders and padding.\n    itemMargin: 0,\n    //{NEW} Integer: Margin between carousel items.\n    minItems: 1,\n    //{NEW} Integer: Minimum number of carousel items that should be visible. Items will resize fluidly when below this.\n    maxItems: 0,\n    //{NEW} Integer: Maxmimum number of carousel items that should be visible. Items will resize fluidly when above this limit.\n    move: 0,\n    //{NEW} Integer: Number of carousel items that should move on animation. If 0, slider will move all visible items.\n    allowOneSlide: true,\n    //{NEW} Boolean: Whether or not to allow a slider comprised of a single slide\n    // Browser Specific\n    isFirefox: false,\n    // {NEW} Boolean: Set to true when Firefox is the browser used.\n    // Callback API\n    start: function () {},\n    //Callback: function(slider) - Fires when the slider loads the first slide\n    before: function () {},\n    //Callback: function(slider) - Fires asynchronously with each slider animation\n    after: function () {},\n    //Callback: function(slider) - Fires after each slider animation completes\n    end: function () {},\n    //Callback: function(slider) - Fires when the slider reaches the last slide (asynchronous)\n    added: function () {},\n    //{NEW} Callback: function(slider) - Fires after a slide is added\n    removed: function () {},\n    //{NEW} Callback: function(slider) - Fires after a slide is removed\n    init: function () {},\n    //{NEW} Callback: function(slider) - Fires after the slider is initially setup\n    rtl: false //{NEW} Boolean: Whether or not to enable RTL mode\n\n  }; //FlexSlider: Plugin Function\n\n  $.fn.flexslider = function (options) {\n    if (options === undefined) {\n      options = {};\n    }\n\n    if (typeof options === \"object\") {\n      return this.each(function () {\n        var $this = $(this),\n            selector = options.selector ? options.selector : \".slides > li\",\n            $slides = $this.find(selector);\n\n        if ($slides.length === 1 && options.allowOneSlide === false || $slides.length === 0) {\n          $slides.fadeIn(400);\n\n          if (options.start) {\n            options.start($this);\n          }\n        } else if ($this.data('flexslider') === undefined) {\n          new $.flexslider(this, options);\n        }\n      });\n    } else {\n      // Helper strings to quickly perform functions on the slider\n      var $slider = $(this).data('flexslider');\n\n      switch (options) {\n        case \"play\":\n          $slider.play();\n          break;\n\n        case \"pause\":\n          $slider.pause();\n          break;\n\n        case \"stop\":\n          $slider.stop();\n          break;\n\n        case \"next\":\n          $slider.flexAnimate($slider.getTarget(\"next\"), true);\n          break;\n\n        case \"prev\":\n        case \"previous\":\n          $slider.flexAnimate($slider.getTarget(\"prev\"), true);\n          break;\n\n        default:\n          if (typeof options === \"number\") {\n            $slider.flexAnimate(options, true);\n          }\n\n      }\n    }\n  };\n})(jQuery);","map":null,"metadata":{},"sourceType":"script"}